#!/bin/bash

# Chattingo Environment and Secrets Management Script
# This script helps manage environment variables and Kubernetes secrets securely

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ENV_DIR="$SCRIPT_DIR/env"
K8S_DIR="$SCRIPT_DIR"

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to show usage
show_usage() {
    cat << EOF
Usage: $0 [COMMAND] [OPTIONS]

Commands:
    init            Initialize environment files from templates
    validate        Validate environment files
    create-secrets  Create Kubernetes secrets from environment files
    update-secrets  Update existing Kubernetes secrets
    backup-secrets  Backup current secrets to encrypted files
    restore-secrets Restore secrets from backup files
    encrypt         Encrypt environment files
    decrypt         Decrypt environment files
    help            Show this help message

Options:
    -e, --env       Environment (dev, staging, prod)
    -n, --namespace Kubernetes namespace (default: chattingo)
    -f, --file      Specific environment file
    --dry-run       Show what would be done without executing
    --force         Force operation without confirmation

Examples:
    $0 init
    $0 validate -e prod
    $0 create-secrets -e dev
    $0 update-secrets -e prod -n chattingo
    $0 encrypt -f .env.prod
    $0 backup-secrets -e prod

EOF
}

# Function to initialize environment files
init_env_files() {
    print_status "Initializing environment files..."
    
    # Create env directory if it doesn't exist
    mkdir -p "$ENV_DIR"
    
    # Copy template files if they don't exist
    for env in dev staging prod; do
        env_file="$ENV_DIR/.env.$env"
        if [[ ! -f "$env_file" ]]; then
            if [[ -f "$ENV_DIR/.env.template" ]]; then
                cp "$ENV_DIR/.env.template" "$env_file"
                print_success "Created $env_file from template"
            else
                print_warning "Template file not found. Creating basic $env_file"
                create_basic_env_file "$env_file" "$env"
            fi
        else
            print_warning "$env_file already exists, skipping"
        fi
    done
    
    # Create .env symlink for current environment
    if [[ ! -L "$ENV_DIR/.env" ]]; then
        ln -s ".env.dev" "$ENV_DIR/.env"
        print_success "Created .env symlink pointing to .env.dev"
    fi
    
    print_success "Environment initialization complete!"
    print_warning "Remember to customize the environment files with your actual values"
}

# Function to create basic environment file
create_basic_env_file() {
    local file=$1
    local env=$2
    
    cat > "$file" << EOF
# $env Environment Configuration
# Generated by Chattingo deployment script

SPRING_PROFILES_ACTIVE=$env
SPRING_DATASOURCE_URL=jdbc:mysql://mysql-service:3306/chattingo_${env}_db
SPRING_DATASOURCE_USERNAME=chattingo_user
SPRING_DATASOURCE_PASSWORD=CHANGE_ME_${env^^}_PASSWORD
JWT_SECRET=CHANGE_ME_${env^^}_JWT_SECRET
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://chattingo.local
REACT_APP_API_BASE_URL=http://chattingo.local/api
MYSQL_ROOT_PASSWORD=CHANGE_ME_${env^^}_ROOT_PASSWORD
EOF
}

# Function to validate environment files
validate_env_files() {
    local env=${1:-"all"}
    local has_errors=false
    
    print_status "Validating environment files..."
    
    if [[ "$env" == "all" ]]; then
        envs=("dev" "staging" "prod")
    else
        envs=("$env")
    fi
    
    for e in "${envs[@]}"; do
        env_file="$ENV_DIR/.env.$e"
        print_status "Validating $env_file..."
        
        if [[ ! -f "$env_file" ]]; then
            print_error "Environment file $env_file not found"
            has_errors=true
            continue
        fi
        
        # Check for placeholder values
        if grep -q "CHANGE_ME" "$env_file"; then
            print_error "Found placeholder values in $env_file - please update them"
            grep --color=always "CHANGE_ME" "$env_file" || true
            has_errors=true
        fi
        
        # Check for required variables
        required_vars=("SPRING_DATASOURCE_PASSWORD" "JWT_SECRET" "MYSQL_ROOT_PASSWORD")
        for var in "${required_vars[@]}"; do
            if ! grep -q "^$var=" "$env_file"; then
                print_error "Required variable $var not found in $env_file"
                has_errors=true
            fi
        done
        
        # Check JWT secret length (should be at least 32 characters)
        jwt_secret=$(grep "^JWT_SECRET=" "$env_file" | cut -d'=' -f2- | tr -d '"' | tr -d "'")
        if [[ ${#jwt_secret} -lt 32 ]]; then
            print_error "JWT_SECRET in $env_file is too short (minimum 32 characters)"
            has_errors=true
        fi
        
        if [[ "$has_errors" == "false" ]]; then
            print_success "$env_file validation passed"
        fi
    done
    
    if [[ "$has_errors" == "true" ]]; then
        print_error "Validation failed! Please fix the errors above."
        exit 1
    else
        print_success "All environment files validated successfully!"
    fi
}

# Function to create Kubernetes secrets
create_k8s_secrets() {
    local env=${1:-"dev"}
    local namespace=${2:-"chattingo"}
    local dry_run=${3:-false}
    
    env_file="$ENV_DIR/.env.$env"
    
    if [[ ! -f "$env_file" ]]; then
        print_error "Environment file $env_file not found"
        exit 1
    fi
    
    print_status "Creating Kubernetes secrets for $env environment in namespace $namespace..."
    
    # Source the environment file
    set -a
    source "$env_file"
    set +a
    
    # Create namespace if it doesn't exist
    if [[ "$dry_run" == "false" ]]; then
        kubectl create namespace "$namespace" --dry-run=client -o yaml | kubectl apply -f -
    fi
    
    # Backend secrets
    print_status "Creating backend secrets..."
    backend_secret_args=(
        "--from-literal=JWT_SECRET=$JWT_SECRET"
        "--from-literal=SPRING_DATASOURCE_USERNAME=$SPRING_DATASOURCE_USERNAME"
        "--from-literal=SPRING_DATASOURCE_PASSWORD=$SPRING_DATASOURCE_PASSWORD"
    )
    
    if [[ "$dry_run" == "true" ]]; then
        print_status "DRY RUN: Would create secret chattingo-backend-secrets"
        kubectl create secret generic chattingo-backend-secrets \
            "${backend_secret_args[@]}" \
            --namespace="$namespace" \
            --dry-run=client -o yaml
    else
        kubectl create secret generic chattingo-backend-secrets \
            "${backend_secret_args[@]}" \
            --namespace="$namespace" \
            --save-config \
            -o yaml --dry-run=client | kubectl apply -f -
        print_success "Created chattingo-backend-secrets"
    fi
    
    # MySQL secrets
    print_status "Creating MySQL secrets..."
    mysql_secret_args=(
        "--from-literal=MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD"
        "--from-literal=MYSQL_USER=${MYSQL_USER:-chattingo_user}"
        "--from-literal=MYSQL_PASSWORD=${MYSQL_PASSWORD:-$SPRING_DATASOURCE_PASSWORD}"
    )
    
    if [[ "$dry_run" == "true" ]]; then
        print_status "DRY RUN: Would create secret mysql-secrets"
        kubectl create secret generic mysql-secrets \
            "${mysql_secret_args[@]}" \
            --namespace="$namespace" \
            --dry-run=client -o yaml
    else
        kubectl create secret generic mysql-secrets \
            "${mysql_secret_args[@]}" \
            --namespace="$namespace" \
            --save-config \
            -o yaml --dry-run=client | kubectl apply -f -
        print_success "Created mysql-secrets"
    fi
    
    # Grafana secrets (if monitoring namespace)
    if [[ "$namespace" == "chattingo-monitoring" ]] || [[ -n "$GF_SECURITY_ADMIN_PASSWORD" ]]; then
        print_status "Creating Grafana secrets..."
        grafana_secret_args=(
            "--from-literal=admin-user=${GF_SECURITY_ADMIN_USER:-admin}"
            "--from-literal=admin-password=${GF_SECURITY_ADMIN_PASSWORD:-admin123}"
        )
        
        if [[ "$dry_run" == "true" ]]; then
            print_status "DRY RUN: Would create secret grafana-secrets"
            kubectl create secret generic grafana-secrets \
                "${grafana_secret_args[@]}" \
                --namespace="chattingo-monitoring" \
                --dry-run=client -o yaml
        else
            kubectl create namespace chattingo-monitoring --dry-run=client -o yaml | kubectl apply -f -
            kubectl create secret generic grafana-secrets \
                "${grafana_secret_args[@]}" \
                --namespace="chattingo-monitoring" \
                --save-config \
                -o yaml --dry-run=client | kubectl apply -f -
            print_success "Created grafana-secrets"
        fi
    fi
    
    print_success "All secrets created successfully!"
}

# Function to update existing secrets
update_k8s_secrets() {
    local env=${1:-"dev"}
    local namespace=${2:-"chattingo"}
    
    print_status "Updating existing Kubernetes secrets..."
    
    # Delete existing secrets
    print_status "Removing old secrets..."
    kubectl delete secret chattingo-backend-secrets --namespace="$namespace" --ignore-not-found=true
    kubectl delete secret mysql-secrets --namespace="$namespace" --ignore-not-found=true
    kubectl delete secret grafana-secrets --namespace="chattingo-monitoring" --ignore-not-found=true
    
    # Create new secrets
    create_k8s_secrets "$env" "$namespace" false
}

# Function to backup secrets
backup_secrets() {
    local env=${1:-"dev"}
    local namespace=${2:-"chattingo"}
    local backup_dir="$ENV_DIR/backups"
    
    mkdir -p "$backup_dir"
    
    print_status "Backing up secrets from namespace $namespace..."
    
    timestamp=$(date +"%Y%m%d_%H%M%S")
    backup_file="$backup_dir/secrets_${env}_${timestamp}.yaml"
    
    {
        echo "# Secrets backup for $env environment"
        echo "# Created: $(date)"
        echo "# Namespace: $namespace"
        echo "---"
        kubectl get secrets chattingo-backend-secrets -n "$namespace" -o yaml 2>/dev/null || echo "# chattingo-backend-secrets not found"
        echo "---"
        kubectl get secrets mysql-secrets -n "$namespace" -o yaml 2>/dev/null || echo "# mysql-secrets not found"
        echo "---"
        kubectl get secrets grafana-secrets -n "chattingo-monitoring" -o yaml 2>/dev/null || echo "# grafana-secrets not found"
    } > "$backup_file"
    
    print_success "Secrets backed up to $backup_file"
    
    # Encrypt the backup
    if command -v gpg &> /dev/null; then
        print_status "Encrypting backup..."
        gpg --symmetric --cipher-algo AES256 --compress-algo 1 --s2k-digest-algo SHA512 \
            --cert-digest-algo SHA512 --compress-level 3 "$backup_file"
        rm "$backup_file"
        print_success "Encrypted backup created: ${backup_file}.gpg"
    else
        print_warning "GPG not available, backup not encrypted"
    fi
}

# Function to encrypt environment files
encrypt_env_file() {
    local file=${1:-""}
    
    if [[ -z "$file" ]]; then
        print_error "Please specify a file to encrypt"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        print_error "File $file not found"
        exit 1
    fi
    
    if ! command -v gpg &> /dev/null; then
        print_error "GPG is required for encryption but not installed"
        exit 1
    fi
    
    print_status "Encrypting $file..."
    gpg --symmetric --cipher-algo AES256 --compress-algo 1 --s2k-digest-algo SHA512 \
        --cert-digest-algo SHA512 --compress-level 3 "$file"
    
    print_success "File encrypted: ${file}.gpg"
    print_warning "Consider removing the original unencrypted file"
}

# Function to decrypt environment files
decrypt_env_file() {
    local file=${1:-""}
    
    if [[ -z "$file" ]]; then
        print_error "Please specify a file to decrypt"
        exit 1
    fi
    
    if [[ ! -f "$file" ]]; then
        print_error "File $file not found"
        exit 1
    fi
    
    if ! command -v gpg &> /dev/null; then
        print_error "GPG is required for decryption but not installed"
        exit 1
    fi
    
    print_status "Decrypting $file..."
    gpg --decrypt "$file" > "${file%.gpg}"
    
    print_success "File decrypted: ${file%.gpg}"
}

# Parse command line arguments
COMMAND=""
ENVIRONMENT="dev"
NAMESPACE="chattingo"
FILE=""
DRY_RUN=false
FORCE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        init|validate|create-secrets|update-secrets|backup-secrets|restore-secrets|encrypt|decrypt|help)
            COMMAND="$1"
            shift
            ;;
        -e|--env)
            ENVIRONMENT="$2"
            shift 2
            ;;
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -f|--file)
            FILE="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        *)
            print_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# Execute commands
case "$COMMAND" in
    init)
        init_env_files
        ;;
    validate)
        validate_env_files "$ENVIRONMENT"
        ;;
    create-secrets)
        validate_env_files "$ENVIRONMENT"
        create_k8s_secrets "$ENVIRONMENT" "$NAMESPACE" "$DRY_RUN"
        ;;
    update-secrets)
        validate_env_files "$ENVIRONMENT"
        if [[ "$FORCE" == "false" ]]; then
            print_warning "This will delete and recreate all secrets. Continue? (y/N)"
            read -r response
            if [[ ! "$response" =~ ^[Yy]$ ]]; then
                print_status "Operation cancelled"
                exit 0
            fi
        fi
        update_k8s_secrets "$ENVIRONMENT" "$NAMESPACE"
        ;;
    backup-secrets)
        backup_secrets "$ENVIRONMENT" "$NAMESPACE"
        ;;
    encrypt)
        if [[ -n "$FILE" ]]; then
            encrypt_env_file "$FILE"
        else
            encrypt_env_file "$ENV_DIR/.env.$ENVIRONMENT"
        fi
        ;;
    decrypt)
        if [[ -n "$FILE" ]]; then
            decrypt_env_file "$FILE"
        else
            print_error "Please specify a file to decrypt with -f option"
            exit 1
        fi
        ;;
    help|"")
        show_usage
        ;;
    *)
        print_error "Unknown command: $COMMAND"
        show_usage
        exit 1
        ;;
esac
